#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

mod login;
mod models;
mod http_client;
mod multi_room;

use std::collections::HashMap;
use reqwest::{Error};
use serde::{Deserialize, Serialize};
use chrono;
use tungstenite::{connect, Message, WebSocket};
use std::env;
use std::net::TcpStream;
use std::ptr::null;
use std::thread;
use serde::de::Unexpected::Option;
use tungstenite::stream::MaybeTlsStream;
use models::{MessageInfo, MessagePage};
use http_client::{get_request, post_json};
use crate::http_client::empty_headers;
use crate::multi_room::{create_new_room, get_room_users, join_room};

#[tauri::command]
async fn send_message(message:&str) -> Result<(), String> {
    let nickname = env::var("CHATNICKNAME")
        .unwrap_or_else(|err| {
            println!("Failed to retrieve nickname: {}", err);
            "".to_string() // Provide a default value or fallback action
        });

    let m = MessageInfo {
        id: 0.to_string(), // auto-generated by the database
        username: nickname,
        time: chrono::offset::Local::now().to_string(),
        message: message.to_string(),
        room_token: get_env_var("ROOMTOKEN")
    };

    let stringified_json = serde_json::to_string(&m).unwrap();
    post_json("/messages", stringified_json.as_str()).await.map_err(|e|e.to_string())
}

#[tauri::command]
async fn ws_handshake() {
    let (mut socket, _) = connect("ws://localhost:8080/ws").expect("Failed to connect");
    loop {
        expect_message(&mut socket);
    }
}

fn expect_message(socket: &mut WebSocket<MaybeTlsStream<TcpStream>>) {
    let message = socket.read_message().expect("Failed to receive message");
    if let Message::Text(json_message) = &message {
        let message: MessageInfo = serde_json::from_str(&json_message).unwrap();
        let message_formatted = serde_json::to_string_pretty(&message).unwrap();
        println!("Received message: {}", message_formatted);
    }
}

#[tauri::command]
async fn get_message_by_id(id: &str) -> Result<String, String>
{
    let endpoint = "/messages/".to_owned() + id;
    get_request(endpoint.as_str(), empty_headers()).await.map_err(|e| e.to_string())
}


#[tauri::command]
async fn get_message_by_page(id: &str) -> Result<String, String>
{
    let endpoint = "/messages/pages/".to_owned() + id;
    get_request(endpoint.as_str(), empty_headers()).await.map_err(|e| e.to_string())
}

#[tauri::command]
async fn get_all_messages() -> Result<String, String> {
    let endpoint = "/messages";
    get_request(endpoint, empty_headers()).await.map_err(|e|e.to_string())
}

#[tauri::command]
async fn auth(username: &str) -> Result<bool, bool> {
    login::auth(username).await
}

#[tauri::command]
fn get_env_var(name: &str) -> String {
    env::var(&name)
        .unwrap_or_else(|err| {
            println!("Failed to retrieve {}: {}", &name, &err);
            "null".to_string() // Provide a default value or fallback action
        })
}

#[tauri::command]
async fn post_new_room() -> String {
    create_new_room().await
}

#[tauri::command]
async fn join_room_by_token(token: String) { join_room(token.as_str()).await }

#[tauri::command]
async fn get_users_in_room() -> String {
    get_room_users(get_env_var("ROOMTOKEN").as_str()).await
}

#[tokio::main]
async fn main() {
    let rt = tokio::runtime::Runtime::new().unwrap();
    let handle = thread::spawn(move || {
        rt.block_on(async {
            ws_handshake().await;
        });
    });

    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            get_message_by_id,
            get_all_messages,
            ws_handshake,
            send_message,
            get_message_by_page,
            auth,
            get_env_var,
            post_new_room,
            join_room_by_token
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");

    handle.join().unwrap();
}
